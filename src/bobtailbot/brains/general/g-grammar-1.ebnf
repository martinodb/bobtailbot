(* EBNF grammar for instaparse *)

(* Careful with the angle brackets. On the left, the node type is omitted from the ptree. On the right, the pattern is omitted.
If you prefer not to omit the node type, instead of using the angle brackets on the left you can simply equate the node type to identity in the transforms map.
For instance, for the node type "FACTS", instead of doing:
<FACTS> = (FACT | AND-FACTS | ...)  ;
here, do:
FACTS = (FACT | AND-FACTS | ...)  ; 
here, and then in the maps g-transforms-mkst and g-transforms-ckst in brain.clj, do:
:FACTS identity

*)

<SENTENCE> =   (ADD-VOCAB | PROD-LIST | NQUERY | FACTS) <";">* ;
<PROD-LIST> = PROD (<';'>+ PROD)* ;
<PROD> = (RULE | QUERY | QUESTION) <';'>* ;
<QUESTION> = ( YNQUESTION | NEG-YNQUESTION | T-DOES-QUESTION | T-WHO-QUESTION | T-WHOM-QUESTION);




(* ADD-VOCAB is currently implemented using the reader to read maps directly, without instaparse, but I'm leaving this here as a stub, in case I decide to use a more complex syntax to introduce vocabulary *)
ADD-VOCAB = <"add"> <whitespace>+ VOC-TYPE <whitespace>+ VOC-MAP (<whitespace> | <";">)* ;
VOC-TYPE = ("verb" | "noun" | "adj" | "adv") ;
VOC-MAP = "{" <whitespace>*  (VMkey <whitespace>+ VMval (<whitespace> | <",">)*)+ <whitespace>*  "}" ;




<VMkey> = #"\:[A-Za-z0-9\-_]+" ;
<VMval> = #"[\"\']?[A-Za-z0-9\-_]+[\"\']?" ;


NEG = (<"it's"> | <"it is">) (<"false"> | (<"not"> (<"the case">)?)) <"that">  ;
PREAFF = (<"it's"> | <"it is">) (<"true"> | <"the case">) <"that">  ;
Q-PREAFF = <"is it"> (<"true"> | <"the case">) <"that">  ;
Q-NEG = <"is it"> (<"false"> | (<"not"> (<"the case">)?)) <"that">  ;


NQUERY = <"query"> NAME ;


<RULE> = (NAMED-RULE | ANON-RULE);
NAMED-RULE = (NAMED-RULE-wtest | NAMED-RULE-notest);
NAMED-RULE-wtest = <"rule"> NAME <":">? RULE-BODY-wtest ;
NAMED-RULE-notest = <"rule"> NAME <":">? RULE-BODY-notest ;
ANON-RULE = (ANON-RULE-wtest | ANON-RULE-notest);
ANON-RULE-wtest = RULE-BODY-wtest;
ANON-RULE-notest = RULE-BODY-notest;

<RULE-BODY-wtest> = FACT <"when"> LHS-wtest  ;
<RULE-BODY-notest> = FACT <"when"> LHS-notest  ;

<LHS-wtest> = <"test"> TEST <','>* <"facts"> R-FACTS  ;
<LHS-notest> = R-FACTS ;





<R-FACTS> = (R-FACT | R-AND-FACTS | R-OR-FACTS | R-NOT-FACTS | R-PREAFF-FACTS)  ;
<R-FACT> = (AFF-R-FACT | NEG-R-FACT);

<AFF-R-FACT> = R-TRIP-FACT-IND2 ;
R-TRIP-FACT-IND2 = T-SUBJECT T-VERB T-OBJECT ;

<NEG-R-FACT> = NEG-R-TRIP-FACT-IND2 ;
NEG-R-TRIP-FACT-IND2 = <NEG> T-SUBJECT T-VERB T-OBJECT ;



R-AND-FACTS = R-FACT (<"and"> (R-FACT | <"("> R-FACTS <")">))+  ;
R-OR-FACTS = R-FACT (<"or"> (R-FACT | <"("> R-FACTS <")">))+  ;

R-NOT-FACTS = <NEG> R-FACTS;
R-PREAFF-FACTS = <PREAFF> R-FACTS;

TEST = (TSEXPR)+ ;
TSEXPR = TS-OPERATOR (TS-ARG)+ ;
<TS-OPERATOR> = ("equals"| "=" | "greater than"| ">" | "lower than" | "<") ;


<TS-ARG> = (T-NP | VAR | FUN-TSEXPR) ;


FUN-TSEXPR = TFUN-HEAD (TFUN-ARG)* ;

<TFUN-HEAD> = STRING ; (* CAREFUL!! *)

<TFUN-ARG> = TS-ARG ;







QUERY = (QUERY-wtest | QUERY-notest);
QUERY-wtest = Q-BODY-wtest;
QUERY-notest = Q-BODY-notest;

<Q-BODY-wtest> = <"match"> QLHS-wtest <';'>* ;
<Q-BODY-notest> = <"match"> QLHS-notest <';'>* ;

<QLHS-wtest> = <"test"> TEST <','>* <"facts"> Q-FACTS  ;
<QLHS-notest> = Q-FACTS ;

<Q-FACTS> = (Q-FACT | Q-AND-FACTS | Q-OR-FACTS | Q-NOT-FACTS | Q-PREAFF-FACTS)  ;


<Q-FACT> = Q-TRIP-FACT ;
<Q-TRIP-FACT> = (AFF-Q-TRIP-FACT | NEG-Q-TRIP-FACT);
<AFF-Q-TRIP-FACT> = Q-TRIP-FACT-IND2 ;
Q-TRIP-FACT-IND2 = T-SUBJECT T-VERB T-OBJECT ;
<NEG-Q-TRIP-FACT> = (PRENEG-Q-TRIP-FACT | EMBNEG-Q-TRIP-FACT);
<PRENEG-Q-TRIP-FACT> = (PRENEG-Q-TRIP-FACT-IND2) ;
PRENEG-Q-TRIP-FACT-IND2 = <NEG> T-SUBJECT T-VERB T-OBJECT ;
<EMBNEG-Q-TRIP-FACT> = (EMBNEG-Q-TRIP-FACT-IND2) ;
EMBNEG-Q-TRIP-FACT-IND2 = T-SUBJECT EMBNEG-T-VERB T-OBJECT ;




Q-AND-FACTS = Q-FACT (<"and"> (Q-FACT | <"("> Q-FACTS <")">))+  ;
Q-OR-FACTS = Q-FACT (<"or"> (Q-FACT | <"("> Q-FACTS <")">))+  ;

Q-NOT-FACTS = <NEG> Q-FACTS;
Q-PREAFF-FACTS = <PREAFF>+ Q-FACTS;





YNQUESTION = (YNQUESTION-wtest | YNQUESTION-notest);
YNQUESTION-wtest =  <Q-PREAFF>? QLHS-wtest <"?">+ <';'>* ;
YNQUESTION-notest =  <Q-PREAFF>? QLHS-notest <"?">+ <';'>* ;


NEG-YNQUESTION = (NEG-YNQUESTION-wtest | NEG-YNQUESTION-notest);
NEG-YNQUESTION-wtest = <Q-NEG> QLHS-wtest <"?">+ <';'>*;
NEG-YNQUESTION-notest = <Q-NEG> QLHS-notest <"?">+ <';'>* ;


D-TRIP-FACT-IND2 = T-SUBJECT VtraInf T-OBJECT ;
WHO-TRIP-FACT-IND2 = VtraPres3 T-NP ;
WHOM-TRIP-FACT-IND2 = T-NP VtraInf ;

T-DOES-QUESTION = <"does"> D-TRIP-FACT-IND2 <"?">+ ;

T-WHO-QUESTION = <"who"> WHO-TRIP-FACT-IND2 <"?">+ ;
T-WHOM-QUESTION = (<"who"> | <"whom">) <"does"> WHOM-TRIP-FACT-IND2 <"?">+ ;


AND-FACTS = FACT (<"and"> (FACT | <"("> FACTS <")">))+  ;
OR-FACTS = FACT (<"or"> (FACT | <"("> FACTS <")">))+  ;

NOT-FACTS = <NEG> FACTS;
PREAFF-FACTS = <PREAFF> FACTS;



FACTS = (FACT | AND-FACTS | OR-FACTS | NOT-FACTS | PREAFF-FACTS)  ;

<FACT> = (ANON-FACT | NAMED-FACT) ;
ANON-FACT = FACT-BODY ;
NAMED-FACT = <"fact"> NAME <":">? FACT-BODY ;



<FACT-BODY> = (TRIP-FACT | NONTRIP-FACT) ;
<TRIP-FACT> = (AFF-TRIP-FACT | NEG-TRIP-FACT) ;
<AFF-TRIP-FACT> = (TRIP-FACT-IND2 | TRIP-FACT-IC | TRIP-FACT-CLASS2) ;
TRIP-FACT-IND2 = T-SUBJECT T-VERB T-OBJECT ;
<NEG-TRIP-FACT> = (PRENEG-TRIP-FACT | EMBNEG-TRIP-FACT) ;
<PRENEG-TRIP-FACT> = (PRENEG-TRIP-FACT-IND2 | PRENEG-TRIP-FACT-IC | PRENEG-TRIP-FACT-CLASS2) ;
PRENEG-TRIP-FACT-IND2 = <NEG> T-SUBJECT T-VERB T-OBJECT ;
<EMBNEG-TRIP-FACT> = (EMBNEG-TRIP-FACT-IND2 | EMBNEG-TRIP-FACT-IC); (* CLASS2 would be confusing*)
EMBNEG-TRIP-FACT-IND2 = T-SUBJECT EMBNEG-T-VERB T-OBJECT ;





<PRENEG-TRIP-FACT-IC> = PRENEG-TRIP-FACT-ISA ;
PRENEG-TRIP-FACT-ISA = <NEG> T-SUBJECT <T-ISA> T-OBJECT-CLASS ;
<PRENEG-TRIP-FACT-CLASS2> = PRENEG-TRIP-FACT-EVERYISA;
PRENEG-TRIP-FACT-EVERYISA = <NEG> <"every"> T-SUBJECT-CLASS <T-ISA> T-OBJECT-CLASS ;






<EMBNEG-TRIP-FACT-IC> = EMBNEG-TRIP-FACT-ISA ;
EMBNEG-TRIP-FACT-ISA = T-SUBJECT <EMBNEG-T-VCOP-IC> T-OBJECT-CLASS ;
EMBNEG-T-VCOP-IC = (<"am not">|<"isn't">|<"is not">|<"aren't">|<"are not">)(<"a">|<"an">|<"a kind of">)? ;







<EMBNEG-T-VERB> = (EMBNEG-T-Vconj | EMBNEG-T-Vvar);
<EMBNEG-T-Vconj> = (<"doesn't"> | <"does not"> ) VtraInf ;
<EMBNEG-T-Vvar> = (<"doesn't do">|<"does not do"> ) VAR <"to">;

<T-Vconj> = VtraPres3 ;
<T-Vvar> = (VAR | <"does"> VAR <"to">) ;

<T-SUBJECT> = (T-NP | VAR);
<T-VERB> = (T-Vconj | T-Vvar);
<T-OBJECT> = (T-NP | VAR);





<TRIP-FACT-IC> = TRIP-FACT-ISA ;
TRIP-FACT-ISA = T-SUBJECT <T-ISA> T-OBJECT-CLASS ;
<TRIP-FACT-CLASS2> = TRIP-FACT-EVERYISA;
TRIP-FACT-EVERYISA = <"every"> T-SUBJECT-CLASS <T-ISA> T-OBJECT-CLASS ;

T-ISA = (<"am">|<"is">|<"are">)(<"a">|<"an">|<"a kind of">)? ;
T-SUBJECT-CLASS = T-N ;
T-OBJECT-CLASS = T-N;

<T-Vconj> = VtraPres3 ;
<T-Vvar> = (VAR | <"does"> VAR <"to">) ;


<T-NP> = (INDNAME | T-DET-P) ;
T-DET-P = <"the"> T-N ;
<INDNAME> = (NNP | GER-OR-TOINF | VALUE) ;

<VAR> = (EXVAR | UNVAR) ;
EXVAR = #"\![A-Za-z][A-Za-z0-9_-]*";
UNVAR = #"\?[A-Za-z][A-Za-z0-9_-]*";



<NAME> = STRING ;

NUMBER = #"[0-9]+" ;

(* <STRING> = #"[A-Za-z][A-Za-z0-9_-]+" ; *)
<STRING> = #"[A-Za-z][A-Za-z0-9\/\._-]+" ;

<STRING-notNNP> = #"[a-z][A-Za-z0-9\/\._-]+" ;

<FIELD> = STRING-notNNP ;


NNP =  NNPtoken (<whitespace> NNPtoken)* ;
<NNPtoken> = #"[A-Z][A-Za-z0-9\-_]+" ;
whitespace = #"\s+" ;

<VALUE> = STRING-quoted | NUMBER ;

STRING-quoted = #"\"[A-Za-z][A-Za-z0-9\/\._-]+\"" ;

<GER-OR-TOINF> = (GERUND | TOINF) ;
<TOINF> = (TOINFcop | TOINFnc) ;

TOINFcop = <"to"> "be" ;

TOINFnc = <"to"> V-INF-OR-PNon3 ;

<V-INF-OR-PNon3> = (VtraInfOrPresNon3 | VintInfOrPresNon3) ;


<VintInfOrPresNon3> = ("walk" | "talk" |"breath");

VtraInf = VtraInfOrPresNon3 ;
VintInf = VintInfOrPresNon3 ;

<GERUND> = (GERUNDtra | GERUNDint | GERUNDcop);


GERUNDint = ("walking"|"talking"|"breathing") ;
GERUNDcop = ("being") ;

<T-N> = T-Nsg (* for now, especially for triples, only nouns in singular forms*)
<T-Nsg> = Nlex-sg ;


<Nlex-sg> = ((Adj)* Nsimp-sg)+ ;



  






NONTRIP-FACT = "just testing nontrip fact" ;
NONTRIP-CONDITION = "just testing nontrip condition" ;



(*Do more tenses*)
<VintConj>  =  (VintPres) ;
<VtraConj> = (VtraPres) ;

<VintPres> = (VintPres3 | VintPresNon3) ;
<VtraPres> = (VtraPres3 | VtraPresNon3) ;



(* in English the conjugated verb in present is like the infinitive, *)
(* except for the 3rd person singular. *)

<VintPresNon3> = VintInfOrPresNon3 ;
<VtraPresNon3> = VtraInfOrPresNon3 ;

VintPres3 = ("walks" | "talks" |"breathes");





(*Do more tenses*)
NegVintConj = (NegVintPres) ;
NegVtraConj = (NegVtraPres) ;


<NegVintPres> = (NegVintPres3 | NegVintPresNon3 ) ;
<NegVtraPres> = (NegVtraPres3 | NegVtraPresNon3);



NegVintPres3 = (<"doesn't"> | <"does not">) VintInf ;
NegVtraPres3 = (<"doesn't"> | <"does not">) VtraInf ;

NegVintPresNon3 = (<"don't"> | <"do not">) VintInf ;
NegVtraPresNon3 = (<"don't"> | <"do not">) VtraInf ;







